# -*- coding: utf-8 -*-
"""final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jp2vLzojtMgLoUGP08bVsa11GQmC_ooC
"""

"""!pip install pyttsx3
!pip install flask-ngrok flask-cors
!pip install pyngrok
!pip install pandas scikit-learn"""

#final codee-----


import pandas as pd
import numpy as np
from flask import Flask, jsonify, request
from flask_cors import CORS
from pyngrok import ngrok
import csv
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import log_loss, accuracy_score,confusion_matrix
from sklearn import preprocessing
from sklearn.metrics import recall_score



app = Flask(__name__)
cors = CORS(app, resources={r"/*": {"origins": "*"}})

# Mount Google Drive
"""from google.colab import drive
drive.mount('/content/drive')"""

l1 = ['back_pain','constipation','abdominal_pain','diarrhoea','mild_fever','yellow_urine',
    'yellowing_of_eyes','acute_liver_failure','fluid_overload','swelling_of_stomach',
    'swelled_lymph_nodes','malaise','blurred_and_distorted_vision','phlegm','throat_irritation',
    'redness_of_eyes','sinus_pressure','runny_nose','congestion','chest_pain','weakness_in_limbs',
    'fast_heart_rate','pain_during_bowel_movements','pain_in_anal_region','bloody_stool',
    'irritation_in_anus','neck_pain','dizziness','cramps','bruising','obesity','swollen_legs',
    'swollen_blood_vessels','puffy_face_and_eyes','enlarged_thyroid','brittle_nails',
    'swollen_extremeties','excessive_hunger','extra_marital_contacts','drying_and_tingling_lips',
    'slurred_speech','knee_pain','hip_joint_pain','muscle_weakness','stiff_neck','swelling_joints',
    'movement_stiffness','spinning_movements','loss_of_balance','unsteadiness',
    'weakness_of_one_body_side','loss_of_smell','bladder_discomfort','foul_smell_of urine',
    'continuous_feel_of_urine','passage_of_gases','internal_itching','toxic_look_(typhos)',
    'depression','irritability','muscle_pain','altered_sensorium','red_spots_over_body','belly_pain',
    'abnormal_menstruation','dischromic _patches','watering_from_eyes','increased_appetite','polyuria','family_history','mucoid_sputum',
    'rusty_sputum','lack_of_concentration','visual_disturbances','receiving_blood_transfusion',
    'receiving_unsterile_injections','coma','stomach_bleeding','distention_of_abdomen',
    'history_of_alcohol_consumption','fluid_overload','blood_in_sputum','prominent_veins_on_calf',
    'palpitations','painful_walking','pus_filled_pimples','blackheads','scurring','skin_peeling',
    'silver_like_dusting','small_dents_in_nails','inflammatory_nails','blister','red_sore_around_nose',
    'yellow_crust_ooze']

disease = ['Fungal infection', 'Allergy', 'GERD', 'Chronic cholestasis',
           'Drug Reaction', 'Peptic ulcer diseae', 'AIDS', 'Diabetes ',
           'Gastroenteritis', 'Bronchial Asthma', 'Hypertension ', 'Migraine',
           'Cervical spondylosis', 'Paralysis (brain hemorrhage)', 'Jaundice',
           'Malaria', 'Chicken pox', 'Dengue', 'Typhoid', 'hepatitis A',
           'Hepatitis B', 'Hepatitis C', 'Hepatitis D', 'Hepatitis E',
           'Alcoholic hepatitis', 'Tuberculosis', 'Common Cold', 'Pneumonia',
           'Dimorphic hemmorhoids(piles)', 'Heart attack', 'Varicose veins',
           'Hypothyroidism', 'Hyperthyroidism', 'Hypoglycemia',
           'Osteoarthristis', 'Arthritis',
           '(vertigo) Paroymsal  Positional Vertigo', 'Acne',
           'Urinary tract infection', 'Psoriasis', 'Impetigo']

# Load data
df = pd.read_csv("dataset/Training.csv")
tr = pd.read_csv("dataset/Testing.csv")

# Prepare features and target
x = df[l1]
y = df["prognosis"]

# Encode target variable
le = preprocessing.LabelEncoder()
le.fit(y)
y_encoded = le.transform(y)

# Split the data
x_train, x_test, y_train, y_test = train_test_split(x, y_encoded, test_size=0.2, random_state=42)

# Prepare test set
testx = tr[l1]
testy = le.transform(tr['prognosis'])

# Initialising classifiers
clf1 = DecisionTreeClassifier()
clf2 = RandomForestClassifier(n_estimators=100)
clf3 = GaussianNB()
clf4 = KNeighborsClassifier(n_neighbors=5, metric='minkowski', p=2)

# Initialize ensemble model
ensemble_model = VotingClassifier(estimators=[('dt', clf1), ('rf', clf2), ('nb', clf3), ('knn', clf4)], voting='soft')
ensemble_model.fit(x_train, y_train)

# Predict on the test set
pred_final_prob = ensemble_model.predict_proba(x_test)

# Calculate and print log loss
print(log_loss(y_test, pred_final_prob))

# Ensure y_test and predictions are correctly processed
print("Classes in y_test:", le.inverse_transform(np.unique(y_test)))
print("Classes in predictions:", le.inverse_transform(np.unique(np.argmax(pred_final_prob, axis=1))))

# Evaluate the model accuracy
results = cross_val_score(ensemble_model, x, y_encoded, cv=5)
print("Cross-validation results:", results)
print("Cross-validation mean accuracy: {:.2f}%".format(results.mean() * 100))


#Creating dictionaries
description_list = dict()
precaution_dict = dict()




def DecisionTree(symptoms):

    # Initialize and train the decision tree classifier
    clf_dt = DecisionTreeClassifier()
    clf_dt.fit(x_train, y_train)

    # Predict using the decision tree classifier
    inputtest = np.zeros(len(l1))
    for symptom in symptoms:
      if str(symptom) in l1:
        inputtest[l1.index(symptom)] = 1
      else:
        print("Invalid symptom:", symptom)

    predicted_disease_index = clf_dt.predict([inputtest])[0]
    predicted_disease = disease[predicted_disease_index]

    # Print accuracy and confusion matrix
    scores_dt = clf_dt.score(x_test, y_test)
    print("Decision Tree")
    print("Accuracy:", "{:.2f}%".format(scores_dt * 100))
    precision_dt = precision_score(y_test, clf_dt.predict(x_test), average='weighted')
    print("Precision:", "{:.2f}%".format(precision_dt * 100))

    recall_dt = recall_score(y_test, clf_dt.predict(x_test), average='macro')
    print("Recall:", "{:.2f}%".format(recall_dt * 100))

    print("Confusion matrix:")
    conf_matrix = confusion_matrix(y_test, clf_dt.predict(x_test))
    print(conf_matrix)

    return predicted_disease



# Extract diseases from training data
disease = df['prognosis'].unique()

# Predict and display information for a sample input from the test set
sample_input = x_test.iloc[0].values.reshape(1, -1)
predicted_disease = DecisionTree(sample_input)

print("Predicted Disease:", predicted_disease)


# Predicting using RandomForest
def randomforest(symptoms):

    # Initialize and train the random forest classifier
    clf_rf = RandomForestClassifier(n_estimators=100)
    clf_rf.fit(x_train, y_train)

    # Predict using the random forest classifier
    inputtest = np.zeros(len(l1))
    for symptom in symptoms:
        if str(symptom) in l1:
            inputtest[l1.index(symptom)] = 1
        else:
            print("Invalid symptom:", symptom)

    predicted_disease_index = clf_rf.predict([inputtest])[0]
    predicted_disease = disease[predicted_disease_index]

    # Print accuracy and confusion matrix
    scores_rf = clf_rf.score(x_test, y_test)
    print("Random Forest")
    print("Accuracy:", "{:.2f}%".format(scores_rf * 100))
    precision_rf = precision_score(y_test, clf_rf.predict(x_test), average= 'weighted')
    print("Precision:", "{:.2f}%".format(precision_rf * 100))

    recall_rf = recall_score(y_test, clf_rf.predict(x_test), average='macro')
    print("Recall:", "{:.2f}%".format(recall_rf * 100))
    print("Confusion matrix:")
    conf_matrix = confusion_matrix(y_test, clf_rf.predict(x_test))
    print(conf_matrix)

    return predicted_disease

# Predict and display information for a sample input from the test set
sample_input = x_test.iloc[0].values.reshape(1, -1)
predicted_disease = randomforest(sample_input)

print("Predicted Disease:", predicted_disease)

#Predicting using NaiveBayes
def NaiveBayes(symptoms):
    from sklearn.naive_bayes import GaussianNB
    from sklearn.metrics import confusion_matrix
    import numpy as np

    # Initialize and train the Naive Bayes classifier
    clf_nb = GaussianNB()
    clf_nb.fit(x_train, y_train)

    # Predict using the Naive Bayes classifier
    inputtest = np.zeros(len(l1))
    for symptom in symptoms:
        if str(symptom) in l1:
            inputtest[l1.index(symptom)] = 1
        else:
            print("Invalid symptom:", symptom)

    predicted_disease_index = clf_nb.predict([inputtest])[0]
    predicted_disease = disease[predicted_disease_index]

    # Print accuracy and confusion matrix
    scores_nb = clf_nb.score(x_test, y_test)
    print("Naive Bayes")
    print("Accuracy:", "{:.2f}%".format(scores_nb * 100))
    precision_nb = precision_score(y_test, clf_nb.predict(x_test),average='weighted')
    print("Precision:", "{:.2f}%".format(precision_nb * 100))
    recall_nb = recall_score(y_test, clf_nb.predict(x_test), average='macro')
    print("Recall:", "{:.2f}%".format(recall_nb * 100))

    print("Confusion matrix:")
    conf_matrix = confusion_matrix(y_test, clf_nb.predict(x_test))
    print(conf_matrix)

    return predicted_disease


# Using Decision tree to get its output using received inputs
sample_input = x_test.iloc[0].values.reshape(1, -1)
predicted_disease = NaiveBayes(sample_input)
print("Predicted Disease:", predicted_disease)

def KNN(symptoms):
    from sklearn.neighbors import KNeighborsClassifier
    from sklearn.metrics import confusion_matrix
    import numpy as np

    # Initialize and train the KNN classifier
    clf_knn = KNeighborsClassifier(n_neighbors=5, metric='minkowski', p=2)
    clf_knn.fit(x_train, y_train)

    # Predict using the KNN classifier
    inputtest = np.zeros(len(l1))
    for symptom in symptoms:
        if str(symptom) in l1:
            inputtest[l1.index(symptom)] = 1
        else:
            print("Invalid symptom:", symptom)

    predicted_disease_index = clf_knn.predict([inputtest])[0]
    predicted_disease = disease[predicted_disease_index]

    # Print accuracy and confusion matrix
    scores_knn = clf_knn.score(x_test, y_test)
    print("K-Nearest Neighbors")
    print("Accuracy:", "{:.2f}%".format(scores_knn * 100))
    precision_knn = precision_score(y_test, clf_knn.predict(x_test),average='weighted')
    print("Precision:", "{:.2f}%".format(precision_knn * 100))
    recall_knn = recall_score(y_test, clf_knn.predict(x_test), average='macro')
    print("Recall:", "{:.2f}%".format(recall_knn * 100))
    print("Confusion matrix:")
    conf_matrix = confusion_matrix(y_test, clf_knn.predict(x_test))
    print(conf_matrix)

    return predicted_disease

# Predict and display information for a sample input from the test set
sample_input = x_test.iloc[0].values.reshape(1, -1)
predicted_disease = KNN(sample_input)

print("Predicted Disease:", predicted_disease)

import numpy as np
def Ensemble(symptoms):

    # Initialize and train the ensemble model
    clf1 = DecisionTreeClassifier()
    clf2 = RandomForestClassifier(n_estimators=100)
    clf3 = GaussianNB()
    clf4 = KNeighborsClassifier(n_neighbors=5, metric='minkowski', p=2)
    ensemble_model = VotingClassifier(estimators=[('dt', clf1), ('rf', clf2), ('nb', clf3), ('knn', clf4)], voting='soft')
    ensemble_model.fit(x_train, y_train)

    # Predict using the ensemble model
    inputtest = np.zeros(len(l1))
    for symptom in symptoms:
        if str(symptom) in l1:
            inputtest[l1.index(symptom)] = 1
        else:
            print("Invalid symptom:", symptom)

    predicted_disease_index = ensemble_model.predict([inputtest])[0]
    predicted_disease = disease[predicted_disease_index]

    # Print accuracy and confusion matrix
    scores_ensemble = ensemble_model.score(x_test, y_test)
    print("Ensemble Learning")
    print("Accuracy:", "{:.2f}%".format(scores_ensemble * 100))
    precision_essemble = precision_score(y_test, ensemble_model.predict(x_test),average='weighted')
    print("Precision:", "{:.2f}%".format(precision_essemble * 100))
    recall_ensemble = recall_score(y_test, ensemble_model.predict(x_test), average='macro')
    print("Recall:", "{:.2f}%".format(recall_ensemble * 100))
    print("Confusion matrix:")
    conf_matrix = confusion_matrix(y_test, ensemble_model.predict(x_test))
    print(conf_matrix)

    return predicted_disease

sample_input = x_test.iloc[0].values.reshape(1, -1)
predicted_disease = Ensemble(sample_input)

print("Predicted Disease:", predicted_disease)

def get_description(disease):
  with open("dataset/symptom_Description.csv") as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    next(csv_reader)  # Skip the header
    for row in csv_reader:
      if row[0] == disease:
        return row[1]

def get_precautions(disease):
  with open("dataset/symptom_precaution.csv") as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    next(csv_reader)  # Skip the header
    for row in csv_reader:
      if row[0] == disease:
        return row[1:5]


# Get the predicted disease from ensemble learning
predicted_disease = Ensemble(sample_input)

# Get the description, precautions, and severity for the predicted disease
description = get_description(predicted_disease)
precautions = get_precautions(predicted_disease)


# Print the results
print("Predicted Disease:", predicted_disease)
print("Description:", description)
print("Precautions:", precautions)

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/predict', methods=['POST'])
def predict():
    symptoms = [request.form['Symptom1'], request.form['Symptom2'], request.form['Symptom3'], request.form['Symptom4']]
    symptoms_vector = [1 if symptom in symptoms else 0 for symptom in l1]

    Name = request.form['Name']
    Symptom1 = request.form['Symptom1']
    Symptom2 = request.form['Symptom2']
    Symptom3 = request.form['Symptom3']
    Symptom4 = request.form['Symptom4']

